## Moving data : movq

```
movq src, dest

movq (%rcx), %rax
```

x86-64는 대표적인 데이터 이동 명령어로 movq를 제공한다. movq의 쓰임새는 위와 같다. 이름이 의미하듯, movq는 ==Source_에 해당하는 값을 Dest_가 나타내는 공간에 이동(저장)시킨다.==
Source와 Dest 자리에 들어갈 수 있는 값의 유형은 다음과 같이 세 종류이다.

|**유형**|**설명**|
|---|---|
|상수 (Immediate)|레지스터나 메모리에 있는 값이 아니라, **명령어 비트 자체에 적는 값**을 의미한다. 16진수 혹은 10진수 정수 앞에 $ 기호를 붙여서 표현한다. 이러한 상수들은 명령어 비트 자체에 1바이트, 2바이트, 또는 4바이트로 인코딩된다. 물론 당연하게도 상수는 Dest 자리에는 올 수 없다. <br> <br> EX) \$0x400, $-533|
|레지스터 (Register)|위에서 설명했던 x86-64의 **16개 레지스터들 중 하나**를 의미한다. 단, %rsp는 스택 포인터로만 사용되기 때문에 사용 범위가 상대적으로 제한적이다. <br> <br> EX) %rax, %r13|
|메모리 (Memory)|레지스터에 의해 주어지는 메모리 주소에서 시작하는 연속적인 8개의 바이트를 의미한다. 한편 x86-64는 메모리의 값을 참조하기 위한 **주소지정방식(Addressing Mode)**이 굉장히 다양한데, 이에 대해서는 바로 이어서 설명하도록 할 것이다. <br> <br> EX) (%rax) : %rax가 가리키는 메모리 주소에서 시작하는 연속적인 8개의 바이트|

정리하면 movq는 다음과 같이 사용될 수 있다. 여기서 주목할 점은 **메모리와 메모리 사이의 데이터 이동은 불가**하다는 것이다. 이를 위해서는 ==메모리에서 값을 읽어와서 레지스터에 저장한 뒤, 그것을 다시 메모리에 적도록 해야 한다.== 하나의 명령어로 메모리 내 이동을 구현하기에는 하드웨어 구현이 상당히 복잡해지고 비효율적이기 때문이다.

![](https://blog.kakaocdn.net/dn/zKFnv/btqCl8UUSuX/0ek7Bimie8vQZ5eQwyspQK/img.png)

참고로 mov 뒤에 붙은 q는 64비트를 의미한다. 즉, **8바이트 데이터의 이동**을 위한 명령어라는 뜻이다. 반면에 movb, movw, movl도 존재한다. 이들은 각각 1바이트, 2바이트, 4바이트 데이터의 이동을 위한 명령어이다. **mov 뒤에 붙은 것이 무엇이냐에 따라서 64비트 레지스터에서 어느 부분을 읽고 쓸지, 또는 주어지는 메모리 주소에서 시작하여 몇 바이트를 읽고 쓸지 달라진다.**

### 메모리 지정 방식

```
D(Rb, Ri, S) -> 의미 : Mem(Reg[Rb] + S * Reg[Ri] + D])

Rb : 메모리 시작 주소를 나타내는 베이스 레지스터 (Register Base)
D : 메모리 시작주소로부터의 오프셋
Ri : 인덱스 레지스터, (%rsp) 사용 불가
S : 인덱스 레지스터의 값을 몇배 더할지 결정하는 스케일 상수
```
![](https://blog.kakaocdn.net/dn/qZnon/btqCjRTS3zE/BcfTYsWmSspxofaEtUPVs1/img.png)

```
movq 0x8(%rdx) (%rdx,%rcx)
```

![](https://blog.kakaocdn.net/dn/bxr3tR/btqCjR0FVtl/4ilnrmKsUe0km8JRwzJe20/img.png)
