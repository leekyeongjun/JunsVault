# Boolean 연산

- Boolean 연산 - 1은 참, 0은 거짓을 의미한다.
	- And (&) : A와 B가 모두 1일 때 1을 출력한다. 
	- Or (|) : A와 B 중 하나만 1이어도 1을 출력한다.
	- Not (~) : A가 1이면 0을, 0이면 1을 출력한다.
	- Xor(^) : A와 B 중 하나만 1이어야 1을 출력한다.

```
Bitwise Operations

		01101001		01101001		01101001
	&	01010101	|	01010101	^	01010101	~	01010101
	------------------------------------------------------------
		01000001		01111101		00111100		10101010
```

Bitwise Operation을 통해 집합을 표현할 수 있다.

```
A : 01101001 {0,3,5,6}
B : 01010101 {0,2,4,6}

A&B (교집합) 01000001 {0,6}
A|B (합집합) 01111101 {0,2,3,4,5,6}
A^B (대칭차집합) 00111100 {2,3,4,5}
~A (여집합) 10010110 {1,2,4,7}
```

Bitwise Operation은 integral type를 만족하면 C에서도 동작한다.
Any Integral data type (비트로 표현되는 수들) : **long, int, short, char, unsigned**

```
[Example]

	~ 0x41 -> 0xBE
	~ 0100 0001 -> 1011 1110
	
	~ 0x00 -> 0xFF
	~ 0000 0000 -> 1111 1111
	
	0x69 & 0x55 -> 0x41
	
			0110 1001
	&		0101 0101
	-----------------
			0100 0001

	0x69 | 0x55 -> 0x7D
	
			0110 1001
	|		0101 0101
	-----------------
			0111 1101
```

---
# Logical Operations (논리 연산자)

- 0은 False, 1은 True
- 0이 아닌 것은 모두 True이다.
	- && (모두 True(0이 아니면) True)
	- || (어느 하나가 True(0이 아니면) True)
	- ! (False(0) 이면 True)

```
[Example]

	!0x41(0이 아니므로 True) -> 0x00
	
	!0x00(0이므로 False) -> 0x01
	
	!!0x41 (0이 아니므로 True) -> 0x01
	
	0x69 && 0x55 -> (둘다 0이 아니므로) 0x01
	
	0x69 || 0x55 -> (둘다 0이 아니므로) 0x01
	
	p && *p (p의 값이 0이 아니면 *p에 접근)

```

>Early Termination : && 연산은 앞에게 0 (False)이면 뒤에 것을 볼 필요도 없이 무조건 False
---
# Shift operations

- Left Shift x << y : x의 비트 값을 y만큼 Left Shift

|변수|bit|
|---|---|
|X|0110 0010|
|X << 3|0001 0000|
|X >> (Logical) 2|0001 1000|
|X >> (Arith) 2|0001 1000|

-  Right Shift x >> y : x의 비트 값을 y만큼 Right Shift
	- Logical Right Shift : 빈칸을 0으로 채움
	- Arithmetic Right Shift : 빈칸을 왼쪽의 가장 중요한 비트로 채움 (Sign bit)

|변수|bit|
|---|---|
|X|1010 0010|
|X << 3|0001 0000|
|X >> (Logical) 2|0010 1000|
|X >> (Arith) 2|1110 1000|

